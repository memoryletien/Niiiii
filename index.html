<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Ni Chủ Tọa</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Pinyon+Script&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #0f0505;
        font-family: "Cinzel", serif;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      #background-image {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -3;
        background-image: url("./back.png");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        opacity: 0.8;
      }

      #bg-gradient {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -2;
        background: radial-gradient(
          circle at 50% 40%,
          rgba(123, 13, 30, 0.5) 0%,
          rgba(74, 14, 22, 0.4) 50%,
          rgba(26, 5, 5, 0.6) 100%
        );
      }

      #black-void {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 5;
        opacity: 0;
        pointer-events: none;
        transition: opacity 1.5s ease;
      }

      #frost-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        pointer-events: none;
        box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.7);
        background: radial-gradient(
          circle,
          transparent 60%,
          rgba(20, 0, 5, 0.3) 100%
        );
      }

      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2;
      }

      #firework-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 6;
        pointer-events: none;
        display: none;
      }

      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding-top: 10vh;
        transition: opacity 0.5s;
      }

      #main-title {
        font-family: "Pinyon Script", cursive;
        font-size: 15vw;
        color: #eebb66;
        margin: 0;
        text-shadow: 0 2px 5px rgba(255, 215, 0, 0.3);
        animation: floatTitle 4s ease-in-out infinite;
        background: linear-gradient(
          to bottom,
          #fceabb 0%,
          #fccd4d 50%,
          #f8b500 51%,
          #fbdf93 100%
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
        line-height: 1.2;
      }

      #mode-indicator {
        font-family: "Cinzel", serif;
        font-size: 3vw;
        font-weight: 700;
        color: #ffd700;
        letter-spacing: 4px;
        text-transform: uppercase;
        margin-top: 10px;
        border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        padding-bottom: 5px;
      }

      #secret-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: "Cinzel", serif;
        font-weight: 700;
        font-size: 8vw;
        width: 90%;
        white-space: normal;
        line-height: 1.3;
        text-transform: uppercase;
        letter-spacing: 4px;
        text-align: center;
        z-index: 100;
        opacity: 0;
        pointer-events: none;
        background: linear-gradient(
          to bottom,
          #fff8db 0%,
          #ffd700 40%,
          #daa520 100%
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        transition: opacity 1.5s ease;
      }

      #lyrics-container {
        position: absolute;
        bottom: 20%;
        width: 100%;
        text-align: center;
        z-index: 20;
        pointer-events: none;
      }
      #lyrics-text {
        font-family: "Pinyon Script", cursive;
        font-size: 6vw;
        color: #fff0f5;
        text-shadow: 0 0 5px rgba(255, 200, 200, 0.5);
        padding: 0 20px;
        transition: all 0.3s ease;
      }

      #webcam-wrapper {
        position: absolute;
        bottom: 20px;
        left: 20px;
        width: 100px;
        height: 75px;
        z-index: 50;
        background: #000;
        border: 1px solid #ffd700;
        border-radius: 4px;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        overflow: hidden;
        opacity: 0.6;
      }
      #webcam-canvas {
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
        border-radius: 2px;
      }
      #cam-stats {
        display: none;
      }

      #start-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(15, 5, 5, 0.9);
        z-index: 100;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: opacity 0.8s;
      }
      .start-btn {
        border: 1px solid #eebb66;
        padding: 15px 30px;
        color: #eebb66;
        font-size: 14px;
        font-family: "Cinzel", serif;
        letter-spacing: 4px;
        text-transform: uppercase;
        background: rgba(0, 0, 0, 0.6);
        margin-bottom: 15px;
        box-shadow: 0 0 20px rgba(238, 187, 102, 0.2);
        transition: all 0.3s;
      }
      .start-note {
        color: #886666;
        font-size: 12px;
        font-style: italic;
      }

      #touch-hint {
        position: absolute;
        bottom: 100px;
        width: 100%;
        text-align: center;
        font-size: 10px;
        color: rgba(255, 215, 0, 0.5);
        pointer-events: none;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      @keyframes floatTitle {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-8px);
        }
      }

      @media (min-width: 768px) {
        #main-title {
          font-size: 80px;
        }
        #mode-indicator {
          font-size: 9px;
        }
        #secret-message {
          font-size: 5vw;
          width: 80%;
        }
        #lyrics-text {
          font-size: 32px;
        }
        #webcam-wrapper {
          width: 150px;
          height: 112px;
          opacity: 1;
        }
        #cam-stats {
          display: block;
          position: absolute;
          bottom: 0;
          left: 0;
          width: 100%;
          text-align: center;
          font-family: "Cinzel", serif;
          font-size: 6px;
          font-weight: 700;
          color: #ffd700;
          letter-spacing: 2px;
          text-transform: uppercase;
          z-index: 26;
          background: rgba(0, 0, 0, 0.8);
          padding: 4px 0;
          border-top: 1px solid #ffd700;
        }
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  </head>
  <body>
    <div id="background-image"></div>
    <div id="black-void"></div>
    <div id="bg-gradient"></div>
    <div id="frost-overlay"></div>

    <div id="canvas-container"></div>
    <canvas id="firework-canvas"></canvas>

    <div id="secret-message">MERRY CHRISTMAS NI CHỦ TỌA</div>

    <div id="ui-layer">
      <h1 id="main-title">Ni là số 1</h1>
      <div id="mode-indicator">SAO MÀ XINH QUÁ VẬY TRỜI</div>
      <div id="touch-hint">SWIPE TO ROTATE &bull; TAP TO SWITCH</div>
    </div>
    <div id="start-overlay">
      <div class="start-btn">NHẤN NÈ NI</div>
      <div class="start-note">♫ Last Christmas</div>
    </div>
    <div id="lyrics-container"><span id="lyrics-text">...</span></div>

    <div id="webcam-wrapper">
      <div id="cam-stats">SCAN</div>
      <canvas id="webcam-canvas"></canvas>
    </div>

    <video
      id="input_video"
      style="display: none; transform: scaleX(-1)"
      playsinline
    ></video>
    <audio id="bg-music" src="./audio.mp3" loop></audio>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      const isMobile =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) || window.innerWidth < 800;

      const ENABLE_POST_PROCESSING = false;

      const TOTAL_PHOTOS = isMobile ? 8 : 20;
      const PARTICLE_RATIO = isMobile ? 0.3 : 1.0;

      const AI_SKIP_FRAMES = isMobile ? 8 : 2;

      const LYRICS_DATA = [
        { time: 0.0, text: "Thiên thượng thiên hạ" },
        { time: 4.0, text: "Vô nhân khả tỉ" },
        { time: 7.13, text: "Thiên thượng thiên hạ" },
        { time: 11.08, text: "Vô nhân khả tỉ" },
        { time: 15.08, text: "Thiên thượng thiên hạ" },
        { time: 18.99, text: "Vô nhân khả tỉ" },
        { time: 23.12, text: "Thiên thượng thiên hạ" },
        { time: 27.02, text: "Vô nhân khả tỉ" },
        { time: 31.06, text: "Thiên thượng thiên hạ" },
        { time: 34.97, text: "Vô nhân khả tỉ" },
      ];

      const zFactor = isMobile ? 1.4 : 1.0;
      const SCENE_CONFIG = {
        scaleFar: isMobile ? 8.0 : 10.0,
        posFar: { x: 0.0, y: isMobile ? -0.2 : -0.6 },
        camZFar: 7.7 * zFactor,
        scaleNear: 10.0,
        posNear: { x: 0.0, y: -0.7 },
        camZNear: 2.5,
        zoomSpeed: 0.1,
        rotateSpeed: 0.08,
      };

      const LAYERS = [
        {
          id: "inner_snow",
          shape: "Snowflake",
          count: Math.floor(1200 * PARTICLE_RATIO),
          opacity: 0.9,
          color: "#ffffff",
          speed: 0.0005,
          size: 0.06,
          radius: 0.48,
          startY: 1.1,
          endY: -0.3,
          drift: 0.01,
          twinkle: false,
          rotateWithJar: true,
        },
        {
          id: "snow_main",
          shape: "Snowflake",
          count: Math.floor(500 * PARTICLE_RATIO),
          opacity: 0.9,
          color: "#e0ffff",
          speed: 0.001,
          size: 0.18,
          radius: 5.0,
          startY: 7.0,
          endY: -6.0,
          drift: 0.05,
          twinkle: true,
          rotateWithJar: true,
        },
        {
          id: "gold_dust",
          shape: "Circle",
          count: Math.floor(500 * PARTICLE_RATIO),
          opacity: 0.8,
          color: "#ffcc00",
          speed: 0.0006,
          size: 0.03,
          radius: 4.5,
          startY: 6.0,
          endY: -4.0,
          drift: 0.08,
          twinkle: true,
          rotateWithJar: true,
        },
      ];

      let scene,
        camera,
        renderer,
        carModel,
        mixer,
        particleSystems = {},
        textureCache = {},
        polaroidTextures = [],
        polaroidGroup,
        clock = new THREE.Clock(),
        bgParticleGroup;
      let isGalleryMode = false,
        lastGesture = "NONE",
        isZoomedIn = false,
        lastSwitchTime = 0,
        lastDropTime = 0,
        jarOffsetY = 0,
        inspectedPhoto = null;
      const SWITCH_COOLDOWN = 1.0;

      const STATE = {
        hand: { detected: false, x: 0.5, y: 0.5, gesture: "NONE" },
        targetRotation: { x: 0, y: 0 },
        currentRotation: { x: 0, y: 0 },
      };

      let isFireworkMode = false;

      let touchStartX = 0,
        touchStartY = 0;
      let isTouching = false;
      let touchLastTap = 0;

      const FW_CONFIG = {
        particleCount: isMobile ? 60 : 500,
        explosionRadius: 25,
        friction: 0.98,
        gravity: 0.04,
        focalLength: 800,
        autoFireRate: isMobile ? 120 : 100,
      };
      let fwCanvas, fwCtx, fwWidth, fwHeight, fwCx, fwCy;
      let fwParticles = [];
      let fwFireworks = [];

      function initFireworkCanvas() {
        fwCanvas = document.getElementById("firework-canvas");
        fwCtx = fwCanvas.getContext("2d");
        resizeFw();
        window.addEventListener("resize", resizeFw);
      }
      function resizeFw() {
        fwWidth = window.innerWidth;
        fwHeight = window.innerHeight;
        fwCanvas.width = fwWidth;
        fwCanvas.height = fwHeight;
        fwCx = fwWidth / 2;
        fwCy = fwHeight / 2;
      }
      const fwRandom = (min, max) => Math.random() * (max - min) + min;

      class Particle3D {
        constructor(x, y, z, color) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.color = color;
          this.size = fwRandom(1, 3);
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(Math.random() * 2 - 1);
          const speed = fwRandom(5, FW_CONFIG.explosionRadius);
          this.vx = speed * Math.sin(phi) * Math.cos(theta);
          this.vy = speed * Math.sin(phi) * Math.sin(theta);
          this.vz = speed * Math.cos(phi);
          this.alpha = 1;
          this.decay = fwRandom(0.015, 0.03);
          this.last2Dx = 0;
          this.last2Dy = 0;
          this.hasMoved = false;
        }
        update() {
          this.vx *= FW_CONFIG.friction;
          this.vy *= FW_CONFIG.friction;
          this.vz *= FW_CONFIG.friction;
          this.vy += FW_CONFIG.gravity;
          this.x += this.vx;
          this.y += this.vy;
          this.z += this.vz;
          this.alpha -= this.decay;
        }
        draw() {
          if (this.alpha <= 0.1) return;
          const scale =
            FW_CONFIG.focalLength / (FW_CONFIG.focalLength + this.z);
          const screenX = fwCx + this.x * scale;
          const screenY = fwCy + this.y * scale;
          if (scale < 0) return;
          const currentSize = this.size * scale;
          if (this.hasMoved) {
            fwCtx.beginPath();
            fwCtx.strokeStyle = this.color;
            fwCtx.lineWidth = currentSize;
            fwCtx.globalAlpha = this.alpha * 0.7;
            fwCtx.moveTo(this.last2Dx, this.last2Dy);
            fwCtx.lineTo(screenX, screenY);
            fwCtx.stroke();
          }
          this.last2Dx = screenX;
          this.last2Dy = screenY;
          this.hasMoved = true;
        }
      }

      class FireworkSeed {
        constructor() {
          this.x = fwRandom(fwWidth * 0.3, fwWidth * 0.7);
          this.y = fwHeight;
          this.targetY = fwRandom(fwHeight * 0.15, fwHeight * 0.35);
          this.speed = fwRandom(8, 12);
          this.angle = -Math.PI / 2;
          this.vx = Math.cos(this.angle) * this.speed;
          this.vy = Math.sin(this.angle) * this.speed;
          this.exploded = false;
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.vy += 0.1;
          if (this.vy >= 0 || this.y <= this.targetY) {
            this.exploded = true;
            this.explode();
          }
        }
        draw() {
          fwCtx.globalAlpha = 1;
          fwCtx.strokeStyle = "#FFD700";
          fwCtx.lineWidth = 2;
          fwCtx.beginPath();
          fwCtx.moveTo(this.x, this.y);
          fwCtx.lineTo(this.x, this.y + 10);
          fwCtx.stroke();
        }
        explode() {
          const originX = this.x - fwCx;
          const originY = this.y - fwCy;
          const originZ = fwRandom(-100, 100);
          const hueBase = fwRandom(40, 50);
          for (let i = 0; i < FW_CONFIG.particleCount; i++) {
            const lightness = fwRandom(50, 80);
            const color = `hsl(${hueBase}, 100%, ${lightness}%)`;
            fwParticles.push(new Particle3D(originX, originY, originZ, color));
          }
        }
      }

      function loopFireworks() {
        if (!isFireworkMode) return;
        fwCtx.globalCompositeOperation = "source-over";
        fwCtx.fillStyle = "rgba(0, 0, 0, 0.2)";
        fwCtx.fillRect(0, 0, fwWidth, fwHeight);
        fwCtx.globalCompositeOperation = "lighter";

        if (Math.random() * FW_CONFIG.autoFireRate < 2)
          fwFireworks.push(new FireworkSeed());

        for (let i = fwFireworks.length - 1; i >= 0; i--) {
          fwFireworks[i].update();
          fwFireworks[i].draw();
          if (fwFireworks[i].exploded) fwFireworks.splice(i, 1);
        }
        for (let i = fwParticles.length - 1; i >= 0; i--) {
          fwParticles[i].update();
          fwParticles[i].draw();
          if (fwParticles[i].alpha <= 0) fwParticles.splice(i, 1);
        }
        requestAnimationFrame(loopFireworks);
      }

      function triggerFireworkMode() {
        if (isFireworkMode) return;
        isFireworkMode = true;

        const tl = gsap.timeline();
        document.getElementById("firework-canvas").style.display = "block";
        tl.to("#black-void", { opacity: 1, duration: 1.5 });
        tl.to("#ui-layer", { opacity: 0, duration: 0.5 }, 0);
        tl.to(
          "#secret-message",
          { opacity: 1, duration: 2, scale: 1.1, ease: "power2.out" },
          0.5
        );

        polaroidGroup.children.forEach((p) => {
          tl.to(
            p.position,
            { x: 0, y: 0, z: 0, duration: 1, ease: "back.in(1.7)" },
            0
          );
          tl.to(
            p.scale,
            { x: 0, y: 0, z: 0, duration: 1, ease: "back.in(1.7)" },
            0
          );
        });
        if (carModel)
          tl.to(
            carModel.scale,
            { x: 0, y: 0, z: 0, duration: 1, ease: "back.in(1.7)" },
            0
          );

        setTimeout(() => {
          loopFireworks();
        }, 800);
      }

      function exitFireworkMode() {
        if (!isFireworkMode) return;
        isFireworkMode = false;
        const tl = gsap.timeline();
        tl.to("#secret-message", { opacity: 0, duration: 0.5, scale: 1 }, 0);
        tl.to("#black-void", { opacity: 0, duration: 1 });
        tl.to("#ui-layer", { opacity: 1, duration: 1 }, 0);

        fwCtx.clearRect(0, 0, fwWidth, fwHeight);
        fwParticles = [];
        fwFireworks = [];
        document.getElementById("firework-canvas").style.display = "none";

        if (carModel)
          tl.to(
            carModel.scale,
            {
              x: SCENE_CONFIG.scaleFar,
              y: SCENE_CONFIG.scaleFar,
              z: SCENE_CONFIG.scaleFar,
              duration: 1.5,
              ease: "elastic.out(1, 0.5)",
            },
            0.5
          );

        polaroidGroup.children.forEach((p) => {
          p.position.copy(p.userData.startPos);
          p.scale.set(1, 1, 1);
          p.material.opacity = 0;
        });
        isGalleryMode = false;
        document.getElementById("mode-indicator").innerText =
          "SAO MÀ XINH QUÁ VẬY";
        gsap.to(camera.position, { z: SCENE_CONFIG.camZFar, duration: 1.5 });
        gsap.to(window, { duration: 1.2, jarOffsetY: 0 });
      }

      function init() {
        const overlay = document.getElementById("start-overlay");
        const audio = document.getElementById("bg-music");

        overlay.addEventListener("click", () => {
          overlay.style.opacity = 0;
          setTimeout(() => overlay.remove(), 500);
          initTouchControls();
          audio.play().catch((e) => {
            console.log("Audio Error:", e);
          });
        });

        const container = document.getElementById("canvas-container");
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, SCENE_CONFIG.camZFar);

        renderer = new THREE.WebGLRenderer({
          antialias: false,
          alpha: true,
          powerPreference: "high-performance",
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.0));
        renderer.toneMapping = THREE.NoToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        container.appendChild(renderer.domElement);

        // TĂNG ÁNH SÁNG ĐỂ LỌ SÁNG HƠN
        scene.environment = null;
        scene.background = null;

        // ÁNH SÁNG MẠNH HƠN ĐỂ LỌ SÁNG
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); // Tăng từ 0.3 lên 1.2
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Tăng từ 0.2 lên 0.8
        scene.add(ambientLight);

        // THÊM ĐÈN CHIẾU SÁNG TỪ PHÍA TRƯỚC
        const frontLight = new THREE.DirectionalLight(0xffffcc, 0.5);
        frontLight.position.set(0, 5, 10);
        scene.add(frontLight);

        // THÊM ĐÈN CHIẾU SÁNG TỪ HAI BÊN
        const sideLight1 = new THREE.PointLight(0xffcc99, 0.4, 20);
        sideLight1.position.set(8, 3, 0);
        scene.add(sideLight1);

        const sideLight2 = new THREE.PointLight(0x99ccff, 0.4, 20);
        sideLight2.position.set(-8, 3, 0);
        scene.add(sideLight2);

        loadTextures();
        setupBackgroundParticles();
        loadPolaroidTextures();
        LAYERS.forEach(createLayerSystem);
        createPolaroids();

        new GLTFLoader().load("./car.glb", (gltf) => {
          carModel = gltf.scene;
          carModel.scale.setScalar(SCENE_CONFIG.scaleFar);
          carModel.position.set(
            SCENE_CONFIG.posFar.x,
            SCENE_CONFIG.posFar.y,
            0
          );
          carModel.position.z = -0.5;
          carModel.rotation.set(0, 0, 0);
          if (gltf.animations.length) {
            mixer = new THREE.AnimationMixer(carModel);
            mixer.clipAction(gltf.animations[0]).play();
          }
          scene.add(carModel);
        });

        initFireworkCanvas();
        initHandTracking();

        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          resizeFw();
        });
        animate();
      }

      function initTouchControls() {
        const el = document.getElementById("canvas-container");

        el.addEventListener(
          "touchstart",
          (e) => {
            if (e.touches.length === 1) {
              touchStartX = e.touches[0].clientX;
              touchStartY = e.touches[0].clientY;
              isTouching = true;
            }
          },
          { passive: false }
        );

        el.addEventListener(
          "touchmove",
          (e) => {
            if (!isTouching || isFireworkMode) return;
            e.preventDefault();
            if (e.touches.length === 1) {
              const x = e.touches[0].clientX;
              const y = e.touches[0].clientY;
              const dx = (x - touchStartX) * 0.005;
              const dy = (y - touchStartY) * 0.005;

              if (!isGalleryMode) {
                STATE.targetRotation.x += dy;
                STATE.targetRotation.y += dx;
                STATE.currentRotation.x = STATE.targetRotation.x;
                STATE.currentRotation.y = STATE.targetRotation.y;
                if (carModel) {
                  carModel.rotation.y = STATE.currentRotation.y;
                  carModel.rotation.x = STATE.currentRotation.x;
                }
              }
              touchStartX = x;
              touchStartY = y;
            }
          },
          { passive: false }
        );

        el.addEventListener("touchend", (e) => {
          isTouching = false;
          const now = Date.now();
          if (now - touchLastTap < 300) toggleMode();
          touchLastTap = now;
        });

        let longPressTimer;
        el.addEventListener("touchstart", () => {
          longPressTimer = setTimeout(() => {
            if (isGalleryMode) triggerFireworkMode();
          }, 1500);
        });
        el.addEventListener("touchend", () => clearTimeout(longPressTimer));
      }

      function loadPolaroidTextures() {
        const imgLoader = new THREE.ImageLoader();
        imgLoader.crossOrigin = "anonymous";
        const cacheBuster = Date.now();

        for (let i = 1; i <= TOTAL_PHOTOS; i++) {
          const canvas = document.createElement("canvas");
          canvas.width = 400;
          canvas.height = 500;
          const ctx = canvas.getContext("2d");

          const texture = new THREE.CanvasTexture(canvas);
          texture.colorSpace = THREE.SRGBColorSpace;
          polaroidTextures.push(texture);

          const path = `./images/${i}.png?v=${cacheBuster}`;

          imgLoader.load(
            path,
            (image) => {
              const targetRatio = image.width / image.height;

              const border = 10;
              const containerWidth = canvas.width - border * 2;
              const containerHeight = canvas.height - 80 - border;
              const containerRatio = containerWidth / containerHeight;

              let drawWidth, drawHeight, drawX, drawY;

              if (targetRatio > containerRatio) {
                drawWidth = containerWidth;
                drawHeight = containerWidth / targetRatio;
                drawX = border;
                drawY = border + (containerHeight - drawHeight) / 2;
              } else {
                drawHeight = containerHeight;
                drawWidth = containerHeight * targetRatio;
                drawX = border + (containerWidth - drawWidth) / 2;
                drawY = border;
              }

              // Nền nhẹ hơn để ảnh nổi bật
              ctx.fillStyle = "rgba(255, 255, 255, 0.05)";
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              // Vẽ ảnh gốc
              ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);

              // Viền mỏng
              ctx.strokeStyle = "rgba(0, 0, 0, 0.1)";
              ctx.lineWidth = 1;
              ctx.strokeRect(
                drawX - 1,
                drawY - 1,
                drawWidth + 2,
                drawHeight + 2
              );

              // Hiệu ứng shadow
              ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
              ctx.shadowBlur = 5;
              ctx.shadowOffsetX = 0;
              ctx.shadowOffsetY = 2;
              ctx.strokeStyle = "rgba(0, 0, 0, 0.05)";
              ctx.lineWidth = 1;
              ctx.strokeRect(border, border, containerWidth, containerHeight);
              ctx.shadowBlur = 0;

              // Chữ
              ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx.font = "italic 22px Pinyon Script";
              ctx.textAlign = "center";
              ctx.fillText(`Moment ${i}`, canvas.width / 2, canvas.height - 30);

              texture.needsUpdate = true;
            },
            undefined,
            () => {
              ctx.fillStyle = "rgba(255, 255, 255, 0.05)";
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
              ctx.font = "bold 20px Cinzel";
              ctx.textAlign = "center";
              ctx.fillText("NO IMAGE", canvas.width / 2, canvas.height / 2);

              ctx.font = "italic 22px Pinyon Script";
              ctx.fillText(`Moment ${i}`, canvas.width / 2, canvas.height - 30);

              texture.needsUpdate = true;
            }
          );
        }
      }

      function updateLyrics() {
        const audio = document.getElementById("bg-music");
        const lyricBox = document.getElementById("lyrics-text");
        if (!audio || audio.paused || LYRICS_DATA.length === 0) return;
        const t = audio.currentTime;
        let currentLine = "";
        for (let i = 0; i < LYRICS_DATA.length; i++) {
          if (t >= LYRICS_DATA[i].time) {
            if (i === LYRICS_DATA.length - 1 || t < LYRICS_DATA[i + 1].time) {
              currentLine = LYRICS_DATA[i].text;
              break;
            }
          }
        }
        if (lyricBox.innerText !== currentLine)
          lyricBox.innerText = currentLine;
      }

      function loadTextures() {
        const textureLoader = new THREE.TextureLoader();
        textureCache["Snowflake"] = textureLoader.load("./snow.png");
        const cvs = document.createElement("canvas");
        cvs.width = 64;
        cvs.height = 64;
        const ctx = cvs.getContext("2d");
        const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 30);
        g.addColorStop(0, "rgba(255,255,255,1)");
        g.addColorStop(0.4, "rgba(255,255,255,0.5)");
        g.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, 64, 64);
        textureCache["Circle"] = new THREE.CanvasTexture(cvs);
      }

      function setupBackgroundParticles() {
        const count = isMobile ? 200 : 1500;
        bgParticleGroup = new THREE.Group();
        bgParticleGroup.position.z = -12;
        scene.add(bgParticleGroup);
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for (let i = 0; i < count; i++)
          starPos.push(
            (Math.random() - 0.5) * 180,
            (Math.random() - 0.5) * 120,
            (Math.random() - 0.5) * 60
          );
        starGeo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(starPos, 3)
        );
        bgParticleGroup.add(
          new THREE.Points(
            starGeo,
            new THREE.PointsMaterial({
              color: 0xffeebb,
              size: 0.15,
              transparent: true,
              opacity: 0.8,
            })
          )
        );
      }

      function updateBackgroundParticles(time, dt) {
        if (!bgParticleGroup) return;
        bgParticleGroup.rotation.z = Math.sin(time * 0.02) * 0.02;
        bgParticleGroup.rotation.y = Math.sin(time * 0.03) * 0.03;
      }

      function createPolaroids() {
        polaroidGroup = new THREE.Group();
        const geometry = new THREE.PlaneGeometry(0.8, 1.0);

        const count = TOTAL_PHOTOS;
        const cols = 5;
        const radiusBase = 4.0;
        for (let i = 0; i < count; i++) {
          const material = new THREE.MeshBasicMaterial({
            map: polaroidTextures[i],
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0,
          });
          const polaroid = new THREE.Mesh(geometry, material);
          const row = Math.floor(i / cols);
          const col = i % cols;
          const yBase = -1.5 + row * 1.25;
          const angleStep = (Math.PI * 2 * 0.8) / cols;
          const angleOffset = row % 2 === 0 ? 0 : angleStep / 2;
          const theta = -2.5 + col * angleStep + angleOffset;
          const x = radiusBase * Math.cos(theta);
          const z = radiusBase * Math.sin(theta);
          const targetRotY = Math.atan2(x, z) + Math.PI;
          polaroid.userData = {
            targetPos: new THREE.Vector3(
              x + (Math.random() - 0.5) * 0.2,
              yBase + (Math.random() - 0.5) * 0.3,
              z + (Math.random() - 0.5) * 0.2
            ),
            startPos: new THREE.Vector3(x * 5, yBase * 5, z * 5),
            floatOffset: Math.random() * 100,
            targetRot: { y: targetRotY, z: (Math.random() - 0.5) * 0.2 },
            originalIndex: i,
          };
          polaroid.position.copy(polaroid.userData.startPos);
          polaroid.visible = false;
          polaroidGroup.add(polaroid);
        }
        scene.add(polaroidGroup);
      }

      function createLayerSystem(config) {
        const geo = new THREE.BufferGeometry();
        const pos = [],
          vel = [],
          off = [];
        for (let i = 0; i < config.count; i++) {
          const r = config.radius * Math.sqrt(Math.random());
          const theta = Math.random() * 2 * Math.PI;
          pos.push(
            r * Math.cos(theta),
            config.startY - Math.random() * (config.startY - config.endY),
            r * Math.sin(theta)
          );
          vel.push(Math.random() * 0.4 + 0.6);
          off.push(Math.random() * 100);
        }
        geo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute("velocity", new THREE.Float32BufferAttribute(vel, 1));
        geo.setAttribute("offset", new THREE.Float32BufferAttribute(off, 1));
        const mat = new THREE.PointsMaterial({
          size: config.size,
          color: new THREE.Color(config.color),
          map: textureCache[config.shape],
          transparent: true,
          opacity: config.opacity,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
        });
        const sys = new THREE.Points(geo, mat);
        sys.userData = { config: config };
        particleSystems[config.id] = sys;
        scene.add(sys);
      }

      function toggleMode() {
        if (isFireworkMode) return;
        const now = clock.getElapsedTime();
        if (now - lastSwitchTime < SWITCH_COOLDOWN) return;
        lastSwitchTime = now;
        isGalleryMode = !isGalleryMode;

        if (!isGalleryMode) {
          document.getElementById("mode-indicator").innerText =
            "SAO MÀ XINH QUÁ VẬY TRỜI";
        }

        if (isGalleryMode) {
          gsap.to(window, {
            duration: 1.2,
            jarOffsetY: -8,
            ease: "power2.inOut",
          });
          polaroidGroup.rotation.set(0, 0, 0);
          polaroidGroup.children.forEach((polaroid, index) => {
            polaroid.visible = true;
            polaroid.position.copy(polaroid.userData.startPos);
            polaroid.material.opacity = 0;
            const t = polaroid.userData.targetPos;
            const r = polaroid.userData.targetRot;
            gsap.to(polaroid.position, {
              x: t.x,
              y: t.y,
              z: t.z,
              duration: 1.2,
              ease: "power3.out",
              delay: index * 0.03,
            });
            gsap.to(polaroid.rotation, {
              x: 0,
              y: r.y,
              z: r.z,
              duration: 1.2,
              ease: "power3.out",
              delay: index * 0.03,
            });
            gsap.to(polaroid.material, {
              opacity: 1,
              duration: 0.8,
              delay: index * 0.03,
            });
          });
        } else {
          gsap.to(window, {
            duration: 1.2,
            jarOffsetY: 0,
            ease: "back.out(0.8)",
            delay: 0.2,
          });
          polaroidGroup.children.forEach((polaroid, index) => {
            const s = polaroid.userData.startPos;
            gsap.to(polaroid.position, {
              x: s.x,
              y: s.y,
              z: s.z,
              duration: 1.0,
              ease: "power2.in",
              delay: index * 0.02,
            });
            gsap.to(polaroid.material, {
              opacity: 0,
              duration: 0.8,
              delay: index * 0.02,
            });
          });
        }
      }

      function updateParticles(time) {
        if (isFireworkMode) return;
        Object.values(particleSystems).forEach((sys) => {
          const cfg = sys.userData.config;
          if (cfg.id === "inner_snow") {
            const alpha = 1.0 - Math.abs(jarOffsetY / 5.0);
            sys.material.opacity = Math.max(0, cfg.opacity * alpha);
            sys.position.y = jarOffsetY;
          }
          const positions = sys.geometry.attributes.position.array;
          const velocities = sys.geometry.attributes.velocity.array;
          const offsets = sys.geometry.attributes.offset.array;
          for (let i = 0; i < positions.length / 3; i++) {
            let ix = i * 3,
              iy = i * 3 + 1,
              iz = i * 3 + 2;
            positions[iy] -= velocities[i] * cfg.speed * 10;
            if (cfg.drift) {
              positions[ix] +=
                Math.cos(time * 0.5 + offsets[i]) * cfg.drift * 0.1;
              positions[iz] +=
                Math.sin(time * 0.3 + offsets[i]) * cfg.drift * 0.1;
            }
            if (positions[iy] < cfg.endY) {
              positions[iy] = cfg.startY;
              const r = cfg.radius * Math.sqrt(Math.random());
              const t = Math.random() * 2 * Math.PI;
              positions[ix] = r * Math.cos(t);
              positions[iz] = r * Math.sin(t);
            }
            if (cfg.id === "inner_snow") {
              const d = Math.sqrt(
                positions[ix] * positions[ix] + positions[iz] * positions[iz]
              );
              if (d > cfg.radius) {
                const ratio = (cfg.radius - 0.02) / d;
                positions[ix] *= ratio;
                positions[iz] *= ratio;
              }
            }
          }
          sys.geometry.attributes.position.needsUpdate = true;
          if (
            carModel &&
            cfg.rotateWithJar &&
            inspectedPhoto === null &&
            !isTouching
          ) {
            sys.rotation.y = carModel.rotation.y;
            sys.rotation.x = carModel.rotation.x;
          }
        });
      }

      function updatePolaroids(time) {
        if (isFireworkMode) return;
        if (!polaroidGroup) return;
        polaroidGroup.children.forEach((p, i) => {
          if (p === inspectedPhoto) return;
          if (isGalleryMode && p.material.opacity > 0.5) {
            const off = p.userData.floatOffset;
            p.position.y =
              p.userData.targetPos.y + Math.sin(time * 0.8 + off) * 0.15;
            p.rotation.z =
              p.userData.targetRot.z + Math.sin(time * 0.7 + off) * 0.08;
          }
        });
        if (isGalleryMode && inspectedPhoto === null) {
          polaroidGroup.rotation.y = carModel.rotation.y;
          polaroidGroup.rotation.x = carModel.rotation.x;
        }
      }

      function getClosestPolaroid() {
        if (!polaroidGroup) return null;
        let closest = null;
        let minDistance = Infinity;
        polaroidGroup.children.forEach((p) => {
          const worldPos = new THREE.Vector3();
          p.getWorldPosition(worldPos);
          const distance = worldPos.distanceTo(camera.position);
          if (distance < minDistance && distance < 6.0) {
            minDistance = distance;
            closest = p;
          }
        });
        return closest;
      }

      function animatePhotoPopup(show) {
        const now = clock.getElapsedTime();
        if (show) {
          if (inspectedPhoto || now - lastDropTime < 0.8) return;
          inspectedPhoto = getClosestPolaroid();
          if (!inspectedPhoto) return;
          scene.attach(inspectedPhoto);
          inspectedPhoto.visible = true;
          inspectedPhoto.material.opacity = 1;
          gsap.to(inspectedPhoto.position, {
            x: 0,
            y: 0,
            z: camera.position.z - 2.5,
            duration: 0.8,
            ease: "back.out(1.2)",
          });
          gsap.to(inspectedPhoto.rotation, { x: 0, y: 0, z: 0, duration: 0.8 });
          gsap.to(inspectedPhoto.scale, {
            x: 1.4,
            y: 1.4,
            z: 1.4,
            duration: 0.8,
          });
        } else {
          if (!inspectedPhoto) return;
          const p = inspectedPhoto;
          inspectedPhoto = null;
          lastDropTime = now;
          polaroidGroup.attach(p);
          const t = isGalleryMode ? p.userData.targetPos : p.userData.startPos;
          const r = p.userData.targetRot;
          gsap.to(p.position, {
            x: t.x,
            y: t.y,
            z: t.z,
            duration: 0.8,
            ease: "back.out(1.0)",
          });
          gsap.to(p.scale, { x: 1, y: 1, z: 1, duration: 0.7 });
          if (isGalleryMode)
            gsap.to(p.rotation, {
              x: 0,
              y: r.y,
              z: r.z,
              duration: 0.7,
              ease: "power2.out",
            });
          else gsap.to(p.material, { opacity: 0, duration: 0.5 });
        }
      }

      function initHandTracking() {
        const video = document.getElementById("input_video");
        const canvas = document.getElementById("webcam-canvas");
        const ctx = canvas.getContext("2d");
        const stats = document.getElementById("cam-stats");
        const hands = new Hands({
          locateFile: (file) =>
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });

        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 0,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });

        hands.onResults((results) => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          ctx.save();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
          STATE.hand.gesture = "NONE";
          if (results.multiHandLandmarks.length > 0) {
            STATE.hand.detected = true;
            const lm = results.multiHandLandmarks[0];
            STATE.hand.x = 1 - lm[0].x;
            STATE.hand.y = lm[0].y;
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let extended = [];
            for (let i = 0; i < 4; i++)
              extended.push(
                Math.hypot(lm[tips[i]].x - lm[0].x, lm[tips[i]].y - lm[0].y) >
                  Math.hypot(lm[pips[i]].x - lm[0].x, lm[pips[i]].y - lm[0].y)
              );
            const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            const isFist = extended.every((e) => e === false);

            if (extended[0] && extended[1] && !extended[2] && !extended[3])
              STATE.hand.gesture = "VICTORY";
            else if (isFist) STATE.hand.gesture = "FIST";
            else if (pinchDist < 0.05) STATE.hand.gesture = "PINCH";
            else STATE.hand.gesture = "OPEN";
          } else {
            if (STATE.hand.detected) {
              STATE.hand.detected = false;
              STATE.hand.gesture = "NONE";
            }
          }
          ctx.restore();
        });

        let frameCounter = 0;
        const cameraUtils = new Camera(video, {
          onFrame: async () => {
            if (frameCounter % AI_SKIP_FRAMES === 0) {
              await hands.send({ image: video });
            }
            frameCounter++;
          },
          width: 320,
          height: 240,
        });
        cameraUtils.start();
      }

      function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();

        if (mixer) mixer.update(dt);
        updateLyrics();
        updateParticles(time);
        updatePolaroids(time);
        updateBackgroundParticles(time, dt);

        const currentGesture = STATE.hand.gesture;

        if (currentGesture === "VICTORY" && lastGesture !== "VICTORY")
          toggleMode();
        if (currentGesture === "PINCH") {
          isZoomedIn = true;
          if (isGalleryMode) animatePhotoPopup(true);
        }
        if (currentGesture === "OPEN") {
          isZoomedIn = false;
          if (isGalleryMode) animatePhotoPopup(false);
          if (isFireworkMode) exitFireworkMode();
        }
        if (currentGesture === "FIST" && isGalleryMode && !isFireworkMode) {
          triggerFireworkMode();
        }

        lastGesture = currentGesture;

        if (isTouching) {
        } else if (STATE.hand.detected) {
          const targetY = (STATE.hand.x - 0.5) * (Math.PI * 6.0);
          const targetX = (STATE.hand.y - 0.5) * (Math.PI * 1.0);

          STATE.currentRotation.x += (targetX - STATE.currentRotation.x) * 0.1;
          STATE.currentRotation.y += (targetY - STATE.currentRotation.y) * 0.1;

          if (inspectedPhoto === null) {
            if (!isGalleryMode) {
              if (carModel) {
                carModel.rotation.y = STATE.currentRotation.y;
                carModel.rotation.x = STATE.currentRotation.x;
              }
            } else if (carModel) {
              carModel.rotation.y = STATE.currentRotation.y * 0.5;
              carModel.rotation.x = STATE.currentRotation.x * 0.5;
            }
          }
        } else if (carModel && !isGalleryMode && inspectedPhoto === null) {
          carModel.rotation.y += 0.4 * dt;
          carModel.rotation.x *= 0.95;
          STATE.currentRotation.y = carModel.rotation.y;
          STATE.currentRotation.x = carModel.rotation.x;
        }

        if (!isGalleryMode) {
          let ts, tp, tz;
          if (isZoomedIn) {
            ts = SCENE_CONFIG.scaleNear;
            tp = SCENE_CONFIG.posNear;
            tz = SCENE_CONFIG.camZNear;
          } else {
            ts = SCENE_CONFIG.scaleFar;
            tp = SCENE_CONFIG.posFar;
            tz = SCENE_CONFIG.camZFar;
          }
          camera.position.z +=
            (tz - camera.position.z) * SCENE_CONFIG.zoomSpeed;
          if (carModel) {
            carModel.scale.setScalar(
              carModel.scale.x +
                (ts - carModel.scale.x) * SCENE_CONFIG.zoomSpeed
            );
            carModel.position.x +=
              (tp.x - carModel.position.x) * SCENE_CONFIG.zoomSpeed;
            carModel.position.y +=
              (tp.y - carModel.position.y) * SCENE_CONFIG.zoomSpeed;
          }
        }
        if (carModel) {
          carModel.position.y += jarOffsetY;
          if (jarOffsetY < -2)
            carModel.scale.setScalar(
              (isZoomedIn ? SCENE_CONFIG.scaleNear : SCENE_CONFIG.scaleFar) *
                Math.max(0, 1 - Math.abs(jarOffsetY) / 10)
            );
        }

        renderer.render(scene, camera);
      }
      init();
    </script>
  </body>
</html>

